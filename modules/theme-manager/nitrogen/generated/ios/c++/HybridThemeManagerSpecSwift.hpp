///
/// HybridThemeManagerSpecSwift.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#include "HybridThemeManagerSpec.hpp"

// Forward declaration of `HybridThemeManagerSpec_cxx` to properly resolve imports.
namespace ThemeManager { class HybridThemeManagerSpec_cxx; }

// Forward declaration of `Theme` to properly resolve imports.
namespace margelo::nitro::thememanager { enum class Theme; }
// Forward declaration of `Palette` to properly resolve imports.
namespace margelo::nitro::thememanager { enum class Palette; }
// Forward declaration of `FullTheme` to properly resolve imports.
namespace margelo::nitro::thememanager { enum class FullTheme; }
// Forward declaration of `ThemeManagerPayload` to properly resolve imports.
namespace margelo::nitro::thememanager { struct ThemeManagerPayload; }

#include "Theme.hpp"
#include "Palette.hpp"
#include "FullTheme.hpp"
#include "ThemeManagerPayload.hpp"
#include <functional>

#include "ThemeManager-Swift-Cxx-Umbrella.hpp"

namespace margelo::nitro::thememanager {

  /**
   * The C++ part of HybridThemeManagerSpec_cxx.swift.
   *
   * HybridThemeManagerSpecSwift (C++) accesses HybridThemeManagerSpec_cxx (Swift), and might
   * contain some additional bridging code for C++ <> Swift interop.
   *
   * Since this obviously introduces an overhead, I hope at some point in
   * the future, HybridThemeManagerSpec_cxx can directly inherit from the C++ class HybridThemeManagerSpec
   * to simplify the whole structure and memory management.
   */
  class HybridThemeManagerSpecSwift: public virtual HybridThemeManagerSpec {
  public:
    // Constructor from a Swift instance
    explicit HybridThemeManagerSpecSwift(const ThemeManager::HybridThemeManagerSpec_cxx& swiftPart):
      HybridObject(HybridThemeManagerSpec::TAG),
      _swiftPart(swiftPart) { }

  public:
    // Get the Swift part
    inline ThemeManager::HybridThemeManagerSpec_cxx& getSwiftPart() noexcept {
      return _swiftPart;
    }

  public:
    inline size_t getExternalMemorySize() noexcept override {
      return _swiftPart.getMemorySize();
    }
    void dispose() noexcept override {
      _swiftPart.dispose();
    }

  public:
    // Properties
    inline Theme getTheme() noexcept override {
      auto __result = _swiftPart.getTheme();
      return static_cast<Theme>(__result);
    }
    inline Palette getPalette() noexcept override {
      auto __result = _swiftPart.getPalette();
      return static_cast<Palette>(__result);
    }
    inline FullTheme getFullTheme() noexcept override {
      auto __result = _swiftPart.getFullTheme();
      return static_cast<FullTheme>(__result);
    }

  public:
    // Methods
    inline void setTheme(FullTheme theme) override {
      auto __result = _swiftPart.setTheme(static_cast<int>(theme));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void setPalette(Palette palette) override {
      auto __result = _swiftPart.setPalette(static_cast<int>(palette));
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }
    inline void listen(const std::function<void(const ThemeManagerPayload& /* payload */)>& callback) override {
      auto __result = _swiftPart.listen(callback);
      if (__result.hasError()) [[unlikely]] {
        std::rethrow_exception(__result.error());
      }
    }

  private:
    ThemeManager::HybridThemeManagerSpec_cxx _swiftPart;
  };

} // namespace margelo::nitro::thememanager
